'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OaiPmh = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bluebird = require('bluebird');

var _co = require('co');

var _co2 = _interopRequireDefault(_co);

var _lodash = require('lodash');

var _request3 = require('request');

var _request4 = _interopRequireDefault(_request3);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// iterable for OAI PMH list results
let OaiPmhListIterable = function (_AsyncIterable) {
  _inherits(OaiPmhListIterable, _AsyncIterable);

  function OaiPmhListIterable(harvester, verb, field) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, OaiPmhListIterable);

    var _this = _possibleConstructorReturn(this, (OaiPmhListIterable.__proto__ || Object.getPrototypeOf(OaiPmhListIterable)).call(this));

    _this.harvester = harvester;
    _this.verb = verb;
    _this.field = field;
    _this.options = options;
    return _this;
  }

  _createClass(OaiPmhListIterable, [{
    key: 'getNext',
    value: function getNext() {
      const self = this;
      return (0, _co2.default)(function* _getNext() {
        if (!self.currentResult || self.currentIndex >= self.currentResult[self.field].length) {
          let res;
          // no results yet?
          if (!self.currentResult) {
            // send first request
            const query = (0, _lodash.clone)(self.options);
            query.verb = self.verb;
            res = yield self.harvester.request({
              url: self.harvester.baseUrl,
              qs: query
            });
          } else {
            // fetch next list
            res = yield self.harvester.request({
              url: self.harvester.baseUrl,
              qs: {
                verb: self.verb,
                resumptionToken: self.currentResult.resumptionToken._
              }
            });
          }

          // parse xml
          const obj = yield (0, _utils.parseOaiPmhXml)(res.body);

          // store current result and initialize index
          self.currentResult = obj[self.verb];
          self.currentIndex = 0;
        }

        const list = self.currentResult[self.field];
        const token = self.currentResult.resumptionToken;
        const ret = list[self.currentIndex++];

        // is this the last element?
        if (self.currentIndex >= list.length) {
          // do we have a resumption token?
          if (token) {
            let cursor = (0, _lodash.get)(token, '$.cursor');
            let completeListSize = (0, _lodash.get)(token, '$.completeListSize');
            if (cursor !== undefined && completeListSize !== undefined) {
              cursor = parseInt(cursor, 10);
              completeListSize = parseInt(completeListSize, 10);
              if (cursor + list.length >= completeListSize) {
                // we got 'em all
                self.done();
              }
            }
          } else {
            // no resumption token
            self.done();
          }
        }

        return ret;
      });
    }
  }]);

  return OaiPmhListIterable;
}(_utils.AsyncIterable);

// main class


let OaiPmh = exports.OaiPmh = function () {
  function OaiPmh(baseUrl) {
    let _options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, OaiPmh);

    this.baseUrl = baseUrl;

    // default options
    this.options = {
      retry: true, // automatically retry in case of status code 503
      retryMin: 5, // wait at least 5 seconds
      retryMax: 600 // wait at maximum 600 seconds
    };
    // set user-provided options
    (0, _lodash.assign)(this.options, _options);
  }

  // OAI-PMH request with retries for status code 503


  _createClass(OaiPmh, [{
    key: 'request',
    value: function request(options) {
      const ctx = this;
      return (0, _co2.default)(function* _request() {
        let res;

        // loop until request succeeds (with retry: true)
        do {
          res = yield (0, _bluebird.promisify)(_request4.default)(options);

          // retry?
          if (res.statusCode === 503 && ctx.options.retry) {
            // get and parse retry-after header
            const retryAfter = res.headers['retry-after'];

            if (!retryAfter) {
              throw new _utils.OaiPmhError('Status code 503 without Retry-After header.');
            }

            // compute seconds to wait
            let retrySeconds;
            if (/^\s*\d+\s*$/.test(retryAfter)) {
              // integer: seconds to wait
              retrySeconds = parseInt(retryAfter, 10);
            } else {
              // http-date: date to await
              const retryDate = new Date(retryAfter);
              if (!retryDate) {
                throw new _utils.OaiPmhError('Status code 503 with invalid Retry-After header.');
              }
              retrySeconds = Math.floor((retryDate - new Date()) / 1000);
            }

            // sanitize
            if (retrySeconds < ctx.options.retryMin) {
              retrySeconds = ctx.options.retryMin;
            }
            if (retrySeconds > ctx.options.retryMax) {
              retrySeconds = ctx.options.retryMax;
            }

            // wait
            yield (0, _utils.sleep)(retrySeconds);
          }
        } while (res.statusCode === 503 && ctx.options.retry);

        if (res.statusCode !== 200) {
          throw new _utils.OaiPmhError(`Unexpected status code ${res.statusCode} (expected 200).`);
        }

        return res;
      });
    }
  }, {
    key: 'getRecord',
    value: function getRecord(identifier, metadataPrefix) {
      const ctx = this;
      return (0, _co2.default)(function* _identify() {
        // send request
        const res = yield ctx.request({
          url: ctx.baseUrl,
          qs: {
            verb: 'GetRecord',
            identifier: identifier,
            metadataPrefix: metadataPrefix
          }
        });

        // parse xml
        const obj = yield (0, _utils.parseOaiPmhXml)(res.body);

        // parse object
        return (0, _lodash.get)(obj, 'GetRecord.record');
      });
    }

    /**
     * Identifies a provider
     *
     * @return {Promise}
     */

  }, {
    key: 'identify',
    value: function identify() {
      const ctx = this;
      return (0, _co2.default)(function* _identify() {
        // send request
        const res = yield ctx.request({
          url: ctx.baseUrl,
          qs: {
            verb: 'Identify'
          }
        });

        // parse xml
        const obj = yield (0, _utils.parseOaiPmhXml)(res.body);

        // parse object
        return obj.Identify;
      });
    }
  }, {
    key: 'listIdentifiers',
    value: function listIdentifiers() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new OaiPmhListIterable(this, 'ListIdentifiers', 'header', options);
    }
  }, {
    key: 'listMetadataFormats',
    value: function listMetadataFormats() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      const ctx = this;
      return (0, _co2.default)(function* _listMetadataFormats() {
        // send request
        const res = yield ctx.request({
          url: ctx.baseUrl,
          qs: {
            verb: 'ListMetadataFormats',
            identifier: options.identifier
          }
        });

        // parse xml
        const obj = yield (0, _utils.parseOaiPmhXml)(res.body);

        // parse object
        return (0, _lodash.get)(obj, 'ListMetadataFormats.metadataFormat');
      });
    }
  }, {
    key: 'listRecords',
    value: function listRecords(options) {
      return new OaiPmhListIterable(this, 'ListRecords', 'record', options);
    }
  }, {
    key: 'listSets',
    value: function listSets() {
      return new OaiPmhListIterable(this, 'ListSets', 'set');
    }
  }]);

  return OaiPmh;
}();